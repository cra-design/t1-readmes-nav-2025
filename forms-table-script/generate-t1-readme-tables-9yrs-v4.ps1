<#
.SYNOPSIS
  validate-bilingual-links-postprocess.ps1
  Post-process existing EN/FR table HTML files (generated by your v3 script) and
  replace a cell's <a> link with a muted placeholder in BOTH languages when either
  EN or FR URL for that cell is invalid (HTTP 4xx/5xx or request error).

.DESCRIPTION
  This script does NOT build tables. It assumes the tables are already generated
  (e.g., by generate-t1-readme-tables-9yrs-v3.ps1) and live as:
      results\<slug>-table-e.htm
      results\<slug>-table-f.htm
  where <slug> entries (e.g., 5005-d1, 5005-s2) are read from recent-T1-forms-9yrs.txt.

  For each slug:
    1) Load EN and FR HTML.
    2) Parse each <tbody> row: <td>YEAR</td> and the next four <td> cells
       (Fillable, Standard, Large print, E-text).
    3) For each of the 4 columns, pair the EN link href with the FR link href.
       If either side is bad (4xx/5xx/error), replace BOTH cells with:
          EN: <span class="small text-muted">Not available</span>
          FR: <span class="small text-muted">Pas disponible</span>
    4) Save the updated HTML back to disk (in place).

  This satisfies: "check whether each set of matching link in the English and French
  tables are both valid. If either invalid, then both links should be replaced..."

  Windows PowerShell 5.1–safe implementation:
   - Reusable HttpClient
   - TLS 1.2 enforced
   - HEAD with automatic GET retry on 405
   - No PS7 operators (no '?:', no '??')

.PARAMETER Root
  Project root folder. Defaults to the script directory.

.PARAMETER Manifest
  Path to recent-T1-forms-9yrs.txt (one slug per line, e.g., 5005-s2)

.EXAMPLE
  .\validate-bilingual-links-postprocess.ps1

.EXAMPLE
  .\validate-bilingual-links-postprocess.ps1 -Root 'C:\my-working-files\GitHub\t1-readmes-nav-2025\forms-table-script'

.NOTES
  Keep your existing v3 generator untouched. Run this AFTER v3 finishes, to patch links.
#>

[CmdletBinding()]
param(
  [string]$Root = $( if ($PSScriptRoot) { $PSScriptRoot } else { Split-Path -Parent $MyInvocation.MyCommand.Path } ),
  [string]$Manifest = $(Join-Path $( if ($PSScriptRoot) { $PSScriptRoot } else { Split-Path -Parent $MyInvocation.MyCommand.Path } ) 'recent-T1-forms-9yrs.txt'),
  [switch]$EnableConsoleHttpDebug
)

# ---------------------------
# HTTP bootstrap for WinPS 5.1
# ---------------------------
try {
  [void][System.Net.ServicePointManager]::SecurityProtocol
  $global:__origTls = [System.Net.ServicePointManager]::SecurityProtocol
  [System.Net.ServicePointManager]::SecurityProtocol = $global:__origTls -bor [System.Net.SecurityProtocolType]::Tls12
} catch { }

$script:HttpClient = $null
function New-HttpClient {
  if ($script:HttpClient -ne $null) { return $script:HttpClient }

  $handler = New-Object System.Net.Http.HttpClientHandler
  $handler.AllowAutoRedirect = $true
  $handler.MaxAutomaticRedirections = 10

  $client = New-Object System.Net.Http.HttpClient($handler)
  $client.Timeout = [TimeSpan]::FromSeconds(30)
  $client.DefaultRequestHeaders.UserAgent.ParseAdd("Mozilla/5.0 (Windows NT 10.0; Win64; x64) PowerShell/5.1 (+https://aka.ms/powershell)")

  $script:HttpClient = $client
  return $script:HttpClient
}

function Test-UrlStatus {
  param([Parameter(Mandatory=$true)][string]$Url)

  $client = New-HttpClient
  $u = $Url.Trim()

  function _mkres([bool]$ok,[Nullable[Int32]]$code,[string]$method,[string]$err,[Uri]$finalUri) {
    [PSCustomObject]@{
      IsGood   = $ok
      Code     = $code
      Method   = $method
      Error    = $err
      FinalUri = $finalUri
    }
  }

  try {
    $req  = New-Object System.Net.Http.HttpRequestMessage([System.Net.Http.HttpMethod]::Head, $u)
    $resp = $client.SendAsync($req, [System.Net.Http.HttpCompletionOption]::ResponseHeadersRead).GetAwaiter().GetResult()
    $code = [int]$resp.StatusCode
    $finalUri = $resp.RequestMessage.RequestUri

    if ($code -eq 405) {
      if ($EnableConsoleHttpDebug) { Write-Host ("[HTTP] {0} -> 405 (HEAD), retry GET" -f $u) }
      $req.Dispose(); $resp.Dispose()

      $req2  = New-Object System.Net.Http.HttpRequestMessage([System.Net.Http.HttpMethod]::Get, $u)
      $resp2 = $client.SendAsync($req2, [System.Net.Http.HttpCompletionOption]::ResponseHeadersRead).GetAwaiter().GetResult()
      $code2 = [int]$resp2.StatusCode
      $finalUri2 = $resp2.RequestMessage.RequestUri

      $ok2 = ($code2 -ge 200 -and $code2 -lt 400)
      if ($EnableConsoleHttpDebug) { Write-Host ("[HTTP] {0} -> {1} (GET)" -f $u, $code2) }
      $req2.Dispose(); $resp2.Dispose()
      return _mkres $ok2 $code2 "GET" $null $finalUri2
    } else {
      $ok = ($code -ge 200 -and $code -lt 400)
      if ($EnableConsoleHttpDebug) { Write-Host ("[HTTP] {0} -> {1} (HEAD)" -f $u, $code) }
      $req.Dispose(); $resp.Dispose()
      return _mkres $ok $code "HEAD" $null $finalUri
    }
  } catch {
    $msg = $_.Exception.Message
    if ($EnableConsoleHttpDebug) { Write-Host ("[HTTP] {0} -> ERROR: {1}" -f $u, $msg) }
    return _mkres $false $null "HEAD" $msg $null
  }
}

function Test-BilingualLinkPair {
  param([string]$EnUrl,[string]$FrUrl)
  $en = if ([string]::IsNullOrWhiteSpace($EnUrl)) { $null } else { Test-UrlStatus -Url $EnUrl }
  $fr = if ([string]::IsNullOrWhiteSpace($FrUrl)) { $null } else { Test-UrlStatus -Url $FrUrl }

  # Treat missing URL as bad
  $enGood = $false
  $frGood = $false
  if ($en -ne $null -and $en.IsGood -and $en.Code -ge 200 -and $en.Code -lt 400) { $enGood = $true }
  if ($fr -ne $null -and $fr.IsGood -and $fr.Code -ge 200 -and $fr.Code -lt 400) { $frGood = $true }

  [PSCustomObject]@{
    Available = ($enGood -and $frGood)
    En        = $en
    Fr        = $fr
  }
}

# ---------------------------
# HTML parsing / rewriting
# ---------------------------

# Extract rows from a CRA table that looks like the provided samples:
#   <tbody>
#     <tr>
#       <td>YYYY</td>
#       <td>... Fillable ...</td>
#       <td>... Standard ...</td>
#       <td>... Large print ...</td>
#       <td>... E-text ...</td>
#     </tr>
#   </tbody>
#
# Returns: array of PSCustomObject with properties:
#   Year, Cells (string[] length 4), Hrefs (string[] length 4 where present or $null)
function Parse-CraTableRows {
  param([string]$Html)

  $rows = @()
  # Narrow to tbody for safer matching
  $tbodyMatch = [regex]::Match($Html, '<tbody>(?<body>[\s\S]*?)</tbody>', 'IgnoreCase')
  if (-not $tbodyMatch.Success) { return $rows }

  $tbody = $tbodyMatch.Groups['body'].Value
  $trRegex = New-Object System.Text.RegularExpressions.Regex '<tr>(?<row>[\s\S]*?)</tr>', 'IgnoreCase'
  $tdRegex = New-Object System.Text.RegularExpressions.Regex '<td>(?<cell>[\s\S]*?)</td>', 'IgnoreCase'
  $hrefRegex = New-Object System.Text.RegularExpressions.Regex 'href\s*=\s*"(.*?)"', 'IgnoreCase'

  foreach ($trm in $trRegex.Matches($tbody)) {
    $rowHtml = $trm.Groups['row'].Value
    $tds = @()
    foreach ($tdm in $tdRegex.Matches($rowHtml)) {
      $tds += $tdm.Groups['cell'].Value
    }
    if ($tds.Count -lt 5) { continue } # need Year + 4 cells

    $year = $tds[0]
    $cells = @($tds[1], $tds[2], $tds[3], $tds[4])

    $hrefs = @()
    foreach ($c in $cells) {
      $hm = $hrefRegex.Match($c)
      if ($hm.Success) { $hrefs += $hm.Groups[1].Value } else { $hrefs += $null }
    }

    $rows += [PSCustomObject]@{
      Year  = $year
      Cells = $cells
      Hrefs = $hrefs
    }
  }
  return $rows
}

# Rebuild the <tbody> by combining Year + 4 cells for each row
function Build-CraTbodyHtml {
  param([object[]]$Rows)
  $sb = New-Object System.Text.StringBuilder
  foreach ($r in $Rows) {
    [void]$sb.AppendLine('      <tr>')
    [void]$sb.AppendLine("        <td>$($r.Year)</td>")
    for ($i=0; $i -lt 4; $i++) {
      [void]$sb.AppendLine("        <td>$($r.Cells[$i])</td>")
    }
    [void]$sb.AppendLine('      </tr>')
  }
  return $sb.ToString()
}

# Replace the existing <tbody>…</tbody> with a new one
function Replace-Tbody {
  param([string]$Html,[string]$NewTbodyInner)
  return [regex]::Replace($Html, '<tbody>[\s\S]*?</tbody>', "<tbody>`r`n$NewTbodyInner    </tbody>", 'IgnoreCase')
}

# Muted placeholders
$EN_PLACEHOLDER = '<span class="small text-muted">Not available</span>'
$FR_PLACEHOLDER = '<span class="small text-muted">Pas disponible</span>'

function Patch-One-Form {
  param([string]$EnPath,[string]$FrPath)

  if (-not (Test-Path -LiteralPath $EnPath)) { Write-Host "Skip (missing EN): $EnPath"; return }
  if (-not (Test-Path -LiteralPath $FrPath)) { Write-Host "Skip (missing FR): $FrPath"; return }

  $enHtml = Get-Content -LiteralPath $EnPath -Raw
  $frHtml = Get-Content -LiteralPath $FrPath -Raw

  $enRows = Parse-CraTableRows -Html $enHtml
  $frRows = Parse-CraTableRows -Html $frHtml

  if ($enRows.Count -ne $frRows.Count) {
    Write-Host "Warning: row count mismatch EN($($enRows.Count)) vs FR($($frRows.Count)) for $([IO.Path]::GetFileName($EnPath))"
  }

  $rowCount = [Math]::Min($enRows.Count, $frRows.Count)
  for ($r = 0; $r -lt $rowCount; $r++) {
    for ($c = 0; $c -lt 4; $c++) {
      $enUrl = $enRows[$r].Hrefs[$c]
      $frUrl = $frRows[$r].Hrefs[$c]

      $pair = Test-BilingualLinkPair -EnUrl $enUrl -FrUrl $frUrl
      if (-not $pair.Available) {
        # Replace both cells with placeholders, keep the cell structure minimal
        $enRows[$r].Cells[$c] = $EN_PLACEHOLDER
        $frRows[$r].Cells[$c] = $FR_PLACEHOLDER
        if ($EnableConsoleHttpDebug) {
          $enCode = if ($pair.En -and $pair.En.Code) { $pair.En.Code } else { $null }
          $frCode = if ($pair.Fr -and $pair.Fr.Code) { $pair.Fr.Code } else { $null }
          Write-Host ("[PAIR BAD] Row={0} Col={1} EN={2} FR={3}" -f ($r+1), ($c+1), $enCode, $frCode)
        }
      } else {
        if ($EnableConsoleHttpDebug) {
          Write-Host ("[PAIR OK ] Row={0} Col={1}" -f ($r+1), ($c+1))
        }
      }
    }
  }

  # Rebuild tables and write back
  $newEnTbody = Build-CraTbodyHtml -Rows $enRows
  $newFrTbody = Build-CraTbodyHtml -Rows $frRows

  $enOut = Replace-Tbody -Html $enHtml -NewTbodyInner $newEnTbody
  $frOut = Replace-Tbody -Html $frHtml -NewTbodyInner $newFrTbody

  [IO.File]::WriteAllText($EnPath, $enOut, [Text.Encoding]::UTF8)
  [IO.File]::WriteAllText($FrPath, $frOut, [Text.Encoding]::UTF8)

  Write-Host "Patched: $([IO.Path]::GetFileName($EnPath)) and $([IO.Path]::GetFileName($FrPath))"
}

# ---------------------------
# Driver: iterate slugs from manifest
# ---------------------------
if (-not (Test-Path -LiteralPath $Manifest)) {
  throw "Manifest not found: $Manifest"
}
$slugs = Get-Content -LiteralPath $Manifest | Where-Object { -not [string]::IsNullOrWhiteSpace($_) } | ForEach-Object { $_.Trim() }

foreach ($slug in $slugs) {
  $enPath = Join-Path $Root ("results\{0}-table-e.htm" -f $slug)
  $frPath = Join-Path $Root ("results\{0}-table-f.htm" -f $slug)
  Patch-One-Form -EnPath $enPath -FrPath $frPath
}

Write-Host "Done."
